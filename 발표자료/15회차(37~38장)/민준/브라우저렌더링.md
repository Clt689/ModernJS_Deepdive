## 브라우저 렌더링과정
1. html,css,javascript,image,font 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.
2. 브라우저의 렌더링 엔젠은 서버로부터 응답된 HTML과 CSS를 파싱하여 **DOM 과 CSSOM** 을 생성하고 <br> 이를 결합하여 **랜더 트리**를 생성한다.
3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 **자바스크립트를 파싱**하여 **AST**를 생성하고 **바이트 코드로 반환하여 실행**한다.<br>
이때 자바스크립트는 DOM API를 통해 DOM 이나 CSSOM 을 변경할 수 있다. **변경된 DOM 과 CSSOM은 다시 렌더 트리로 결합**된다.
4. 렌더 트리를 기반으로 **HTML 요소의 레이아웃을 계산**하고 브라우저 화면에 HTML 요소를 **페인팅**한다.

## 브라우저의 기능
브라우저의 핵심기능이라 한다면 
1. 필요한 리소스를 **서버에 요청**하고 
2. **서버로 부터 응답**받아
3. 응답받은 **리소스를 파싱**하여
3. 브라우저에 시각적으로 **렌더링**하는것이다.

## 요청
서버에 요청을 전송하기위해 브라우저는 주소창을 제공한다.<br>
브라우저의 주소창에 URL을 입력하고 엔터키를 누르면 **URL**의 호스트 이름이 **DNS를 통해 IP주소로 변환**되고 <br>
이 **IP 주소를 갖는 서버에게 요청을 전송**한다.

## HTML 1.1 과 2.0
HTML 1.1 은 **커넥션당 하나의 요청과 응답**만을 처리한다.
따라서 HTML 문서내에 포함된 여러개의 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송된다

HTML 2.0 은 **커넥션당 여러개의 요청/응답이 가능**하다.
그리하여 이전에비해 페이지 로드속도가 50퍼 이상 증가햇다고 알려져 있다.

## HTML 파싱과 DOM 생성
브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트이다.
<br>
HTML 문서를 브라우저에 시각적인 픽셀로 렌더링 하려면 HTML 문서를 브라우저가 이해할수있는 **DOM 객체로 변환하여 메모리에 저장**해야 한다.
<br>
브라우저의 렌더링 엔진은 해당 순서에 따라 HTML을 파싱하여 브라우저가 이해할수 있는 자료구조인 DOM을 생성한다.

즉 DOM 이란 **HTML 문서를 파싱한 결과물**이다.

## DOM 생성 순서
1. 서버에 존재하던 HTML 파일이 **브라우저의 요청에 응답**된다.

2. **서버**는 브라우저가 요청한 **HTML 파일을 읽어 메모리에 저장**한다.
3. **서버**는 **메모리에 저장된 바이트를 인터넷을 경유하여 응답**한다.
4. **브라우저**는 서버가 응답한 HTML 문서를 **바이트형태로 응답받는다.**
5. 응답된 바이트 형태의 HTML 문서에 **META 태그의 CHARSET 어트리뷰트에 의해 선언된 인코딩 방식**은 **응답해더에 담겨 응답**된다.
6. 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 **토큰들로 분해**한다.
7. 각 토큰들을 객체로 변환하여 **노드들을 생성**한다.
8. 각 노드들은 토큰의 내용에 따라 **다른 노드가 생성**된다.
9. 생성된 노드들은 **DOM 을 구성하는 기본요소**가 된다.
10. HTML문서는 HTML 요소들의 집합으로 이루어지며 HTML 요소는 **중첩 관계**를 맺는다. (HTML안에 다른 HTML 또한 가능)
11. HTML 요소 간의 부자관계를 반영하여 **모든 노드들을 트리자료구조로 구성**한다.
12. 이 **노드들로 구성된 트리자료구조를 DOM**이라고 부른다.

## CSS 파싱과 CSSOM 생성
렌더링엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성해가는데 
CSS를 로드하는 **LINK 태그 혹은 STYLE 태그를 만나면 DOM 생성을 일시 중지**한다.

그후 로드한 CSS 파일이나 STYLE 태그 안의 CSS를 HTML 과 동일한 파싱 과정을 거치며 해석하여 
CSSOM을 생성한다.

**CSSOM을 생성한 후에는 DOM생성을 다시 시작한다.**

## 랜더 트리
렌더링 엔진은 DOM 과 CSSOM을 생성한 후 렌더링을 위해 **렌더트리로 결합**한다.

렌더 트리는 **렌더링을 위한 트리구조의 자료구조** 이다.

따라서 브라우저 화면에 렌더링 되지않는 노드 (meta, script 태그 등등) 은 포함하지 않는다.

## 자바스크립트 파싱과 실행
생성된 DOM은 HTML 문서의 구조와 정보 뿐만아니라 HTML 요소와 스타일 등을 변경할 수 있는 프로그래밍 인터페이스인 **DOM API**를 제공한다.

CSS 파싱과 동일하게 **SCRIPT 태그를 만나면 DOM 생성을 일시 중단**한다.
이후 **자바스크립트 엔진이 파싱과 실행이 종료되면 DOM 생성을 재실행**한다.

자바스크립트 엔진은 이과정에서 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준언어로 변환하고 실행한다.

자바스크립트 엔진은 DOM 과 CSSOM 처럼 자바스크립트를 해석하여 **AST**를 생성한다. 
AST를 바탕으로 인터프리터가 실행할수있는 중간코드인 바이트코드를 생성하여 실행한다.

## AST
https://gyujincho.github.io/2018-06-19/AST-for-JS-devlopers

과정
1. 자바스크립트 소스코드 
2. 토큰 (TOKENIZER)
3. AST (PARSE) 
4. 바이트코드 (바이트 코드 생성기)
5. 실행 (인터프리터)

## 파싱
토큰들의 집합을 구문 분석하여 AST를 생성한다.
AST는 인터프리터나 컴파일러만이 사용하는것은 아니며 AST를 사용하면 TYPESCRIPT, BABEL, PRETTIER 같은 트랜스파일러를 구현할수도 있다.

## 바이트코드의 생성과 실행
파싱의 결과물로 생성된 AST는 **인터프리터가 실행할수 있는 바이트코드로 변환되고 실행**된다.
V8 엔진의 경우 터보팬이라 불리는 컴파일러에 의해 최적화된 머신코드로 컴파일되어 성능을 최적화한다.

## 리플로우와 리페인트
만약 자바스크립트 코드에서 DOM이나 CSSOM 을 변경하는 DOM API를 사용하는경우 <br>
DOM 과 CSSOM은 다시 렌더트리로 결합되고 **변경된 렌더트리를 기반으로 다시 렌더링**한다 

이러한 과정을 리플로우 , 리페인트 라 한다
- **리플로우** : **레이아웃 재계산**
- **리페인트** : **재결합된 렌더트리를 기반으로 리페인트**

## async/defer script
자바스크립트 파싱에 의해 DOM 생성이 중단되는 문제를 해결하기위해 async, defer 어트리뷰트가 추가되었다.

- async
    - script 태그의 **순서와는 상관없이 로드가 완료**된다.
    - 완료된 자바스크립트부터 실행되어 순서가 보장되지않는다.

- defer
    - **html 파싱이 완료된 직후 진행**된다.