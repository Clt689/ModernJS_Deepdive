# `37.2` Map
> - `Map` 객체는 `키`와 `값`의 쌍으로 이루어진 컬렉션.
> - `Map` 객체는 `객체(Object)`와 유사함
> 
> | 구분 | 객체 | Map |
> |:---:|:---:|:---:|
> 키로  사용할 수 있는 값 | 문자열 또는 심벌 | 객체를 포함한 모든 값 |
> 이터러블 | X | O |
> 요소 개수 확인 | Object.keys(Obj).length | map.size |
>

## `37.2.1` Map 객체의 생성
- Map 생성자 함수는 이터러블을 인수로 전달 받아 Map 객체 생성
- 인수로 전달되는 이터러블은 `key`와 `value`의 쌍으로 이루어진 요소로 구성

``` js
// 생성자 함수의 인수가 비어있으면 빈 Map 객체 생성
const map = new Map();
console.log(map); // Map(0) {}


// 이터러블을 인수로 전달받아 Map 객체 생성
const map1 = new Map([['key1', 'value1'], ['key2', 'value2']]);
console.log(map1) // map(2) { 'key1' => 'value1', 'key2' => 'value2' }


// 키&값이 아닌 요소는 타입에러 발생
const map2 = new Map([1,2]) // TypeError: Iterator value 1 is not an entry object


// 중복된 키를 갖는 요소가 존재하면 값을 수정
const map3 = new Map([['key1', 'value1'], ['key1', 'value2']]);
console.log(map3) // Map(1) { 'key1' => 'value2' }
```

## `37.2.2` 요소 개수 확인
### 요소 개수는 `Map.prototype.size` 프로퍼티를 사용.

  ``` js
  const {size} = new Map([['key1', 'value1'], ['key2', 'value2']]);
  console.log(size); // 2

  map.size = 10 // 무시됨
  console.log(map.size); // 2
  ```

## `37.2.3` 요소 추가
###  요소 추가는 `Map.prototype.set(key, value)` 메서드를 사용.
  
``` js
// set 메서드를 통한 요소 추가
const map = new Map().set('key1', 'value1');
console.log(map); // Map(1) {'key1' => 'value1'}

// 메서드 체이닝을 통한 연속 호출
map.set('key2', 'value2').set('key3', 'value3');
console.log(map) // Map(3) {'key1' => 'value1', 'key2' => 'value2', 'key3' => 'value3'}

// 중복된 키를 갖는 요소 추가하면 값 덮어씌우기
map.set('key1', 'value100');
console.log(map); // Map(3) {'key1' => 'value100', 'key2' => 'value2', 'key3' => 'value3'}

// 객체(Object)는 문자열, 심볼만 키로 사용할 수 있지만 Map은 키타입에 제한이 없음.
const map = new Map();

const lee = {name : 'lee'};
const kim = {name : 'kim'};

map.set(lee, 'developer').set(kim, 'designer');
console.log(map); // Map(2) {{ name: 'lee' } => 'developer', { name: 'kim' } => 'designer'}
```

## `37.2.4` 요소 취득
- `Map.prototype.get(key)` 메서드를 사용하여 특정 키에 해당하는 값을 취득
- `.get(key)`에 해당하는 값이 없으면 `undefined` 반환
``` js
const map = new Map();

const lee = {name : 'lee'};
const kim = {name : 'kim'};
map.set(lee, 'developer').set(kim, 'designer');

map.get(lee) // developer
map.get(kim) // designer
```

## `37.2.4` 요소 존재 여부 확인
### 요소 존재 여부 확인은 `Map.prototype.has` 메서드를 사용.
``` js
const lee = {name : 'Lee'};
const kim = {name : 'Kim'};

const map = new Map([[lee, 'developer'], [kim, 'designer']]);
map.has(lee); // true
map.has('jay'); // false
```

## `37.2.5` 요소 삭제
### 요소 삭제는 `Map.prototype.delete(key)` 메서드를 사용.
``` js
const lee = {name : 'Lee'};
const kim = {name : 'Kim'};

const map = new Map([[lee, 'developer'], [kim, 'designer']]);
map.delete(lee);
console.log(map); // Map(1) {{ name: 'kim' } => 'designer'}

// 존재하지 않는 키를 삭제하면 false 반환
map.delete('jay'); // false
console.log(map); // Map(1) {{ name: 'kim' } => 'designer'}

// boolean 값을 반환하므로 set메서드처럼 메서드 체이닝 불가능
map.delete(kim).delete(lee); // TypeError: Cannot read property 'delete' of false
```

## `37.2.6` 전체 요소 삭제
### 전체 요소 삭제는 `Map.prototype.clear()` 메서드를 사용.
``` js
const lee = {name : 'Lee'};
const kim = {name : 'Kim'};
const map = new Map([[lee, 'developer'], [kim, 'designer']]);

map.clear();
console.log(map) // Map(0) {size: 0}
```

## `37.2.7` Map 객체의 요소 순회
### `Map.prototype.forEach` 메서드를 사용하여 Map 객체의 요소를 순회
1. **첫번째 인수** 현재 순회중인 요소 값
2. **두번째 인수** 현재 순회중인 요소 키
3.  **세번째 인수** 순회중인 Map 객체 자체
``` js
const lee = {name : 'Lee'};
const kim = {name : 'Kim'};
const map = new Map([[lee, 'developer'], [kim, 'designer']]);

map.forEach((v, k, map) => console.log(v, k, map))
/*
developer {name: 'Lee'} Map(2) {
{…} => 'developer',
{…} => 'designer'
}
designer {name: 'Kim'} Map(2) {
{…} => 'developer',
{…} => 'designer'
}
*/
```

### Map 객체는 이터러블
``` js
const lee = {name : 'Lee'};
const kim = {name : 'Kim'};
const map = new Map([[lee, 'developer'], [kim, 'designer']]);

// for...of문으로 순회
for(const entry of map) {
  console.log(entry); // [ { name: 'Lee' }, 'developer' ] [ { name: 'Kim' }, 'designer']
}

// 스프레드 문법
console.log([...map]); // [ [ { name: 'Lee' }, 'developer' ], [ { name: 'Kim' }, 'designer' ] ]


// 배열 디스트럭처링 할당
const [a, b] = map;
console.log(a, b); // [ { name: 'Lee' }, 'developer' ] [ { name: 'Kim' }, 'designer' ]
```

### Map 객체는 이터러블이면서 이터레이터인 객체를 반환하는 메서드 제공
- `Map.prototype.keys` : Map 객체의 키를 순회하는 이터레이터를 반환
- `Map.prototype.values` : Map 객체의 값을 순회하는 이터레이터를 반환
- `Map.prototype.entries` : Map 객체의 키&값을 순회하는 이터레이터를 반환
``` js
const lee = {name : 'Lee'};
const kim = {name : 'Kim'};
const map = new Map([[lee, 'developer'], [kim, 'designer']]);

// keys 메서드
for(const key of map.keys()) {
  console.log(key) // {name: 'Lee'} {name: 'Kim'}
}

// values 메서드
for(const value of map.values()) {
  console.log(value) // developer designer
}

// entries 메서드
for(const entry of map.entries()) {
  console.log(entry) // [ { name: 'Lee' }, 'developer' ] [ { name: 'Kim' }, 'designer' ]
}
```


